var $canvas, $video, captureToCanvas, ctx, h, initDom, initWebcam, isCanvasSupported, load, qrReactiveDict, showingCanvas, w;
qrReactiveDict = new ReactiveDict;
this.qrScanner = {
    message: function() {
        return qrReactiveDict.get('message');
    },
    on: function(eventName, callback) {
        return this[eventName] = callback;
    },
    off: function(eventName) {
        return delete this[eventName];
    },
    imageData: function() {
        return ctx.getImageData(0, 0, w, h);
    },
    imageDataURL: function() {
        return $canvas[0].toDataURL("image/jpeg");
    }
};
$canvas = null;
$video = null;
ctx = null;
w = null;
h = null;
showingCanvas = false;
Template._qrScanner.rendered = function() {
    var base, base1;
    showingCanvas = true;
    if (this.data == null) {
        this.data = {};
    }
    w = (base = this.data).w != null ? base.w : base.w = 320;
    h = (base1 = this.data).h != null ? base1.h : base1.h = 240;
    $canvas = $('#qr-canvas');
    $video = $('#qr-scanner-video');
    return load();
};
Template._qrScanner.destroyed = function() {
    showingCanvas = false;
    qrReactiveDict.set('message', null);
    return qrScanner.off('scan');
};
isCanvasSupported = function() {
    var elem;
    elem = document.createElement("canvas");
    return !!(elem.getContext && elem.getContext("2d"));
};
load = function() {
    var err;
    if (isCanvasSupported()) {
        initDom();
        return initWebcam();
    } else {
        err = 'Your browser does not support canvas';
        return console.log(err);
    }
};
initDom = function() {
    $canvas.width(w).attr('width', w);
    $canvas.height(h).attr('height', h);
    ctx = $canvas[0].getContext("2d");
    ctx.clearRect(0, 0, w, h);
};
initWebcam = function() {
	if (MediaStreamTrack.getSources){
		var selectedSource = null;
		return MediaStreamTrack.getSources(function(sources){
			for (var i in sources){
				if (sources[i].kind === 'video'){
					selectedSource = sources[i];
				}
			}
			 if (navigator.webkitGetUserMedia) {
                $video[0].src = window.webkitURL.createObjectURL(selectedSource);
            } else if (navigator.mozGetUserMedia) {
                $video[0].mozSrcObject = selectedSource;
                $video[0].play();
            } else {
                $video[0].src = selectedSource;
            }
			$video[0].src = window.webkitURL.createObjectURL(selectedSource);
			return Meteor.setTimeout(captureToCanvas, 500);
		});
	}
    navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia;
    if (navigator.getUserMedia) {
        return navigator.getUserMedia({
            video: {
                mandatory: {
                    maxWidth: w,
                    maxHeight: h
                },
                optional: []
            },
            audio: false
        }, function(stream) {
            if (navigator.webkitGetUserMedia) {
                $video[0].src = window.webkitURL.createObjectURL(stream);
            } else if (navigator.mozGetUserMedia) {
                $video[0].mozSrcObject = stream;
                $video[0].play();
            } else {
                $video[0].src = stream;
            }
            return Meteor.setTimeout(captureToCanvas, 500);
        }, function(err) {
            return console.log(err);
        });
    } else {
        return console.log('Your borwser doesnt support getUserMedia');
    }
};
captureToCanvas = function() {
    var err, message;
    ctx.drawImage($video[0], 0, 0);
    try {
        message = qrcode.decode();
        qrReactiveDict.set('message', message);
        if (qrScanner.scan) {
            qrScanner.scan(null, message);
        }
    } catch (_error) {
        err = "The QR code isnt visible or couldn't be read";
        if (qrScanner.scan) {
            qrScanner.scan(err, null);
        }
    }
    if (showingCanvas) {
        return Meteor.setTimeout(captureToCanvas, 500);
    }
};
// ---
// generated by coffee-script 1.9.2
